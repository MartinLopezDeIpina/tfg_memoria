\section{Diseño General}
\todo{Esta sección ponerla en diseño del sistema}
El sistema implementado aborda el caso de uso donde el usuario realiza una pregunta y se debe responder consultando las fuentes de datos disponibles. El diseño del sistema está limitado por dos restricciones fundamentales: 
\begin{itemize}
  \item\textbf{Ventana de contexto limitada: }Los proyectos en producción pueden tener millones de líneas de código, con una documentación igualmente extensa. Los modelos del estado del arte no tienen todavía la capacidad de procesar tal volumen de texto. 
  \item\textbf{Costo asociado: }Si bien en algunos casos es posible incluir toda la información disponible en el prompt de los agentes, varias iteraciones con tal volumen de texto conllevarían un sobrecoste prohibitivo. 
\end{itemize}
La arquitectura distribuye el procesamiento entre agentes especializados, evitando que un único agente cargue toda la información. Cada agente interactúa exclusivamente con su fuente de datos asignada, eliminando el sobrecoste de procesar información irrelevante en cada llamada. El agente orquestador analiza la consulta y determina qué agentes especialistas deben intervenir, seleccionando las fuentes de datos más apropiadas para cada caso.

Adicionalmente, se requiere de una coordinación a alto nivel mediante el agente planificador, que razona sobre los pasos lógicos a realizar. Por ejemplo, si el usuario pregunta por ejemplos en los que se utiliza la guía de estilos del proyecto, en lugar de buscar información indiscriminadamente, primero se localizaría la guía de estilos para después examinar implementaciones específicas en el código fuente. 

\section{Conjunto de datos etiquetados}
\label{anexo:datos_et}
Un conjunto de datos etiquetado es una colección estructurada de información donde cada elemento o instancia está asociado a una o más categorías, clases o valores objetivo, denominados etiquetas. Estas etiquetas representan la información que se desea predecir o clasificar mediante un modelo de aprendizaje automático.

En el contexto del aprendizaje supervisado, estos conjuntos constituyen la base para el entrenamiento de modelos, ya que proporcionan ejemplos concretos de la relación entrada-salida que el algoritmo debe aprender a generalizar.



\section{Entrenamiento de redes neuronales}
\label{anexo:entrenamiento}
El entrenamiento de una red neuronal consiste en un proceso iterativo de modificación de los pesos de las conexiones entre neuronas artificiales. Estos ajustes permiten que la red aprenda a generalizar a partir de los datos de entrenamiento, extrayendo patrones subyacentes que podrá aplicar posteriormente a datos no observados.

En el aprendizaje supervisado, específicamente durante el ajuste fino, los pesos se modifican comparando las predicciones del modelo con los datos de referencia. Esta comparación se cuantifica mediante una función de pérdida, cuyos gradientes, calculados mediante la regla de la cadena, indican cómo deben ajustarse los pesos para minimizar el error. Este mecanismo de retropropagación permite que la red optimice progresivamente su capacidad predictiva.

\section{Distancia coseno}
\label{anexo:dis_cos}
La distancia coseno es una medida que cuantifica la similitud entre dos vectores basándose en el coseno del ángulo que forman, independientemente de sus magnitudes. Matemáticamente se expresa como: 

\[Similitud\_coseno(x,y) = \frac{x \cdot y}{|x||y|}\]

El valor 1 indica vectores perfectamente alineados (máxima similitud), 0 representa vectores perpendiculares (sin similitud) y -1 señala vectores en direcciones opuestas (máxima disimilitud.

\section{Tokenizador}
\label{anexo:tokenizer}
Un tokenizador es el componente algorítmico encargado de segmentar el texto en unidades mínimas procesables (tokens), implementando reglas específicas de división basadas en espacios, puntuación, subpalabras o patrones predefinidos según el modelo de lenguaje.

\section{Pool de conexiones asíncronas}
\label{anexo:pool}
Un pool de conexiones asíncronas en PostgreSQL constituye un mecanismo de gestión eficiente que mantiene un conjunto predefinido de conexiones a la base de datos. Cuando una aplicación requiere conectarse a la base de datos, en lugar de crear una nueva conexión, solicita una al pool, que le proporciona una de las conexiones ya establecidas y disponibles. Su naturaleza asíncrona permite ejecutar operaciones sin bloquear el hilo principal, reduciendo la sobrecarga asociada al establecimiento repetitivo de conexiones.


